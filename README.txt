Our program can compute P(N), Q(N) and P(N,m) according to our notations.



-- Structure of the program -----------------------

All sources are in .c files.

 - input.c : contains tool to manage inputs of the program.
 - polynome.c and polynome2var.c : contain functions which manipulate a polynomial.
 - variance_feistel.c : contains functions used to compute Q(N).
 - variance_random.c : contains functions used to compute P(N,m).

The directory include contains all header files. The header file include/common.h contains all structures and configuration values used in the program. You can find some values which can be modified without compiling again in configuration.txt.



-- Compilation ------------------------------------

To generate the program from sources, you can use the Makefile file with the command 'make'.
The name of the program generated by this method is 'var'
Our simulations have been executed on 32-bits and 64-bits Ubuntu systems.



-- Execution --------------------------------------

To launch our program, you can use the command './var input_file' where input_file is a file which describes the attack according to some rules (see "Input file section").

Usage : ./var [OPTIONS] input_file

Options :

	-v : compute the P(N,m) polynomial on a random permutation
	-f : compute the Q(N) on the Feistel scheme too.


Without options, the program computes only the P(N) on a random permutation (with conditions described in input_file).
If needed you can change some values in common.h and compile the program.





-- Input file -------------------------------------

The program uses a parser to read an attack from an input file. Here is an example :

SIZE_SCHEMA = 3
K = 2
PHI = 2
I1(1)+I1(2)+S2(1)+S2(2)=0
I2(1)+I2(2)=0
S1(1)+S1(2)=0


The keywords are SIZE_SCHEMA, K and PHI. 

- SIZE_SCHEMA is the number of conditions in the attack. We can see in the example there are three conditions.
- K is the number of inputs in a round of a Feistel scheme according to our notations
- PHI is the number of points of the attack as we have defined in our notations.

Once these keywords set, user has to write the conditions of the attack according to our notations.
The sign '+' corresponds with the XOR operation. So I2(1)+I2(2)=0 is equivalent to I2(1)=I2(2) and I1(1)+I1(2)+S2(1)+S2(2)=0 to (I1(1) XOR I1(2)) = (S2(1) XOR S2(2)).

If user wants to compute the P(N,m) on a Feistel scheme with "-f" option, he has to add two more keywords in the input_file :

FEISTEL_TYPE = 1
D = 11  

The value of FEISTEL_TYPE can be 1, 2 or 3 :

1 -> Classic Feistel (but we swap left and right part) or Feistel of type 1
2 -> Expanding Feistel. For example for F_3^6 we have in fact D=(3-1)x6=12 rounds
3 -> Feistel of type 2 (multiply the number of round by K/2)

D is the number of round function we are considering in the attack. It can be the same as the number of rounds but not necessary. For example, in Feistel schemes with expanding functions, we have D = (K-1) * r where r is the number of rounds.





-- Configuration file -----------------------------

There is a configuration file : "configuration.txt".
In this file there are some values used by the program. If this file doesn't exist, there are default values.
The aim of this file is to modify the values without compiling after.

In order to have all computation details, you can uncomment the line in the file /include/common.h and then compile with make :
//#define DEBUG





-- One to one functions --------------------------------------

If round functions are one to one functions, then to take it account in the program, you have to uncomment the line in the file /include/common.h and then compile with make :
//#define BIJECTION



-- Approximation ---------------------------------------------

If the aim is to compute the leading terms, you have to set EXACT to FALSE in the file include/common.h. The number of terms is determined by NBTERMES in the same file. Then you have to compile the program with make.

#define EXACT TRUE
#define NBTERMES 2




